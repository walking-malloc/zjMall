## 库存服务 PRD（Inventory Service）

### 1. 背景与目标

#### 1.1 背景

当前系统已具备用户、商品、促销、购物车等核心能力，商品的库存信息主要存在于商品服务内部或仅作为展示字段使用，尚未形成一个独立、可扩展、可支撑高并发下单的库存中心。

在真实电商场景中，库存是强约束资源，必须满足：

- **不超卖**（Oversell）：在高并发下单场景下，不能出现卖出数量大于实际库存的情况。
- **可追踪**：每一次库存变动要有来源（订单、取消、补货等），便于排查与对账。
- **可扩展**：后续可以演进到分仓、预售、锁定库存等更复杂模型。

#### 1.2 目标

设计并实现一个**库存服务（inventory-service）**，提供独立的库存中心能力，主要目标：

- 为每个 SKU 维护**可用库存**。
- 支持**下单扣减 / 订单取消回滚**。
- 支持**对外查询某个 SKU 是否可售、剩余多少库存**。
- 与订单、购物车、商品服务解耦，通过 **gRPC + MQ** 协作完成库存变更。

---

### 2. 术语与概念

- **SKU**：最小库存单位，与商品服务中的 `SKUID` 一一对应。
- **可用库存（available_stock）**：当前可以售卖的数量。
- **预占库存（reserved_stock，可选 v1 简化）**：
  - 下单时先从可用库存转移部分到预占库存；
  - 支付成功再从预占库存扣减；支付超时/取消再释放回可用库存。
  - v1 可以先不实现预占，只实现“直接扣减 + 订单失败时手动回滚”。
- **库存变动记录（stock_log）**：记录每次变动的来源和数量，用于审计与排查。

---

### 3. 业务范围与不做的事情

#### 3.1 本期范围（v1）

- 维护 `sku_id` 维度的可用库存。
- 对外能力：
  - 查询单个 / 多个 SKU 的库存。
  - 校验指定 SKU 在指定数量下是否可售。
- 与订单的交互：
  - 接收“订单创建”事件（MQ） → 尝试扣减库存 → 成功/失败。
  - 接收“订单取消 / 关闭”事件（MQ） → 回滚库存（加回）。
- 提供基础的 gRPC 接口，供商品详情、购物车结算等调用。

#### 3.2 非本期范围（后续演进）

- 分仓库存（多仓、最近仓、跨仓调拨）。
- 预售库存（未来库存、补货计划）。
- 精细的库存锁（按仓库、批次、效期）。
- 实时多副本一致性的强一致架构（v1 以单库为主，尽量简单可用）。

---

### 4. 业务流程

#### 4.1 下单扣减库存流程（简化版）

1. 用户在前端点击“提交订单”（结算页）。
2. 订单服务创建订单（包含 SKU 列表和数量），发送 `OrderCreated` 事件到 MQ。
3. 库存服务消费 `OrderCreated`：
   - 对每个 SKU：
     - 读取当前可用库存；
     - 若 `available_stock >= order_quantity`，则扣减；
     - 否则标记为库存不足。
   - 若任意一个 SKU 库存不足：
     - 记录失败原因；
     - 发送“扣减失败”结果（可通过回调 gRPC 或发送 `StockDeductFailed` 事件）；
4. 订单服务根据库存扣减结果：
   - 全部成功：订单状态进入“待支付”；
   - 存在失败：订单标记为“库存不足/创建失败”，可提示用户。

> 说明：v1 版本可以先不实现复杂的“部分商品有货、部分无货”的拆单逻辑，统一按“全部满足 / 全部失败”处理。

#### 4.2 订单取消 / 关闭库存回滚流程

1. 用户主动取消订单 / 支付超时 / 后台关闭订单。
2. 订单服务发送 `OrderCanceled` 或 `OrderClosed` 事件到 MQ，内容包含订单号和各 SKU 数量。
3. 库存服务消费该事件：
   - 将对应 SKU 的库存数量加回（前提是之前已经扣减过）。
   - 记录一条库存变动日志，类型为“回滚”。

#### 4.3 手工调整 / 补货流程（可选）

- 后台运营可以通过管理系统调用库存服务的管理接口：
  - 直接设置某 SKU 的库存为某个值；
  - 或在当前基础上增/减库存。
- 该部分可以留作后续管理后台接入时实现，PRD 中只预留接口能力。

---

### 5. 功能需求

#### 5.1 库存主表管理（必做）

- 每个 SKU 一条记录，字段（建议）：
  - `id`：主键（可使用雪花 / ULID）。
  - `sku_id`：SKU 唯一标识（与商品服务一致）。
  - `available_stock`：当前可用库存数量（int）。
  - `version`：版本号（用于乐观锁，可选 v1 是否做）。
  - 基础字段：`created_at` / `updated_at`。

能力：

- 创建 / 初始化库存记录（例如上架商品时同步创建）。
- 查询某个 SKU 当前库存。
- 批量查询多个 SKU 库存。

#### 5.2 库存变动日志（推荐做）

- 用于审计每一次库存变动：
  - `id`
  - `sku_id`
  - `change`：正数为加库存，负数为减库存。
  - `reason`：如 `order_created`, `order_canceled`, `manual_adjust` 等。
  - `ref_id`：外部关联 ID（如订单号）。
  - `created_at`

需求：

- 每次库存变动必须写一条日志（可和主表操作放在一个事务里）。
- 日志主要用于开发排查和运营核对，短期不提供复杂查询接口，后续可扩展。

#### 5.3 扣减库存接口

对外 gRPC 接口（示意）：

- `DeductStock(order_id, items[])`：
  - 入参：
    - `order_id`：订单号。
    - `items`：数组，每项包含 `sku_id` 和 `quantity`。
  - 逻辑：
    - 校验每个 `sku_id` 的库存是否足够；
    - 采用**事务 + 行级锁 / 乐观锁**保证并发下不超卖：
      - 简化版可以使用 `UPDATE ... WHERE sku_id = ? AND available_stock >= ?` 的条件更新。
    - 全部扣减成功则返回成功；
    - 任一失败则整体失败，不做部分成功（v1）。

#### 5.4 回滚库存接口

对外 gRPC 接口（示意）：

- `RollbackStock(order_id, items[])`：
  - 入参同上。
  - 逻辑：
    - 将对应 SKU 的 `available_stock` 加回；
    - 可做幂等（例如根据 `order_id + sku_id` 判断是否已回滚过）。

#### 5.5 MQ 集成

- 消费事件：
  - `OrderCreated`：触发 `DeductStock`。
  - `OrderCanceled` / `OrderClosed`：触发 `RollbackStock`。
- 可靠性：
  - 队列 durable，消息持久化（可参考购物车的 MQ 配置）。
  - `autoAck = false` + 手动 `Ack/Nack`。
  - 消费逻辑需幂等（例如对同一个订单的重复事件只处理一次）。

---

### 6. 非功能需求

#### 6.1 可用性

- 库存服务故障时：
  - 下单接口应尽量快速失败，返回“库存服务不可用”，避免长时间卡住用户。
  - 后续可考虑降级策略（只读库存，不允许下单）。

#### 6.2 性能

- 单机 QPS 目标：初期可按**几百 QPS** 设计，重点在于结构正确、无超卖。
- 扣减库存的 SQL 必须走索引（`sku_id` 唯一索引）。

#### 6.3 可观测性

- 需要有基本的日志：
  - 扣减失败原因（库存不足 / SQL 错误等）。
  - MQ 消费失败重试日志。
- 可选：后续接入 Prometheus 指标（成功/失败次数、耗时等）。

---

### 7. 与现有服务的关系

- **商品服务（product-service）**：
  - 定义 SKU（`sku_id`）的基本信息；
  - 库存服务仅依赖 SKU ID，不关心价格、文案等。

- **购物车服务（cart-service）**：
  - 结算时需要调用库存服务接口，校验是否有足够库存。

- **订单服务（未来要做）**：
  - 负责生成订单并发送库存相关事件；
  - 库存服务消费事件，完成实际扣减/回滚。

---

### 8. 里程碑（建议）

- **M1：库存服务雏形**
  - 建表：`inventory_stocks`、`inventory_logs`。
  - 提供基本 gRPC 接口：查询、扣减、回滚。
  - 本地单元测试通过。

- **M2：与订单、MQ 集成**
  - 设计并实现 `OrderCreated` / `OrderCanceled` 消息格式。
  - 库存服务消费 MQ 事件，打通“下单 → 扣减库存 → 取消订单 → 回滚库存”的闭环。

- **M3：优化与观测**
  - 增加幂等策略、错误重试、监控指标。
  - 压测基础场景，优化 SQL 和索引。


